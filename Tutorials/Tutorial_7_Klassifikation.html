<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Andreas Niekler, Gregor Wiedemann" />

<meta name="date" content="2021-03-17" />

<title>Tutorial 7: Classification</title>

<script src="site_libs/header-attrs-2.5/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>
<link href="site_libs/ionicons-2.0.1/css/ionicons.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Intro</a>
</li>
<li>
  <a href="Tutorial_1_Web_scraping.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 1
  </a>
</li>
<li>
  <a href="Tutorial_2_Read_textdata.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 2
  </a>
</li>
<li>
  <a href="Tutorial_3_Frequency.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 3
  </a>
</li>
<li>
  <a href="Tutorial_4_Term_extraction.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 4
  </a>
</li>
<li>
  <a href="Tutorial_5_Co-occurrence.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 5
  </a>
</li>
<li>
  <a href="Tutorial_6_Topic_Models.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 6
  </a>
</li>
<li>
  <a href="Tutorial_7_Klassifikation.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 7
  </a>
</li>
<li>
  <a href="Tutorial_8_NER_POS.html">
    <span class="ion ion-android-bulb"></span>
     
    Tutorial 8
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Tutorial 7: Classification</h1>
<h4 class="author">Andreas Niekler, Gregor Wiedemann</h4>
<h4 class="date">2021-03-17</h4>

</div>


<p><script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('left', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script> In this tutorial we show the use of supervised machine learning for text classification. The basic idea is to compute a model based on training data. Training data usually are hand-coded documents or text snippets associated with a specific category (class). From these texts, features (e.g. words) are extracted and associated with categories in the model. The model then can be utilized to categorize new texts.</p>
<p>We cover basic principles of the process such as cross-validation and feature engineering in the following steps:</p>
<ol style="list-style-type: decimal">
<li>Read text data</li>
<li>Read training data</li>
<li>Build feature matrix</li>
<li>Classify (LiblineaR)</li>
<li>K-fold cross validation</li>
<li>Optimize C</li>
<li>Optimize features: stopwords, bi-grams, stemming</li>
<li>Final classification</li>
</ol>
<p>As data, again we use the “State of the Union”-addresses. But this time, we operate on paragraphs instead of documents. The file <code>data/sotu_paragraphs.csv</code> provides the speeches in the appropriate format. For each paragraph, we want to know whether it covers content related to <strong>domestic or foreign affairs</strong>.</p>
<div id="read-paragraphs" class="section level1" number="1">
<h1 number="1"><span class="header-section-number">1</span> Read paragraphs</h1>
<p>As already known, we read the text source (21334 paragraphs from 231 speeches). For the moment, we apply very basic preprocessing.</p>
<pre class="r"><code>options(stringsAsFactors = FALSE)
library(quanteda)

textdata &lt;- read.csv(&quot;data/sotu_paragraphs.csv&quot;, sep = &quot;;&quot;, encoding = &quot;UTF-8&quot;)

corpus &lt;- corpus(textdata$text, docnames = textdata$doc_id)

# Build a dictionary of lemmas
lemma_data &lt;- read.csv(&quot;resources/baseform_en.tsv&quot;, encoding = &quot;UTF-8&quot;)

# Create a DTM
corpus_token &lt;- corpus %&gt;% 
  tokens(remove_punct = TRUE, remove_numbers = TRUE, remove_symbols = TRUE) %&gt;% 
  tokens_tolower()</code></pre>
</div>
<div id="load-training-data" class="section level1" number="2">
<h1 number="2"><span class="header-section-number">2</span> Load training data</h1>
<p>We provide 300 manually annotated example paragraphs as training data. In a CSV-file, the paragraph id and the corresponding category is stored.</p>
<pre class="r"><code># Read previously annotated training data
trainingData &lt;- read.csv2(&quot;data/paragraph_training_data_format.csv&quot;, stringsAsFactors = T)
# Training data format 
colnames(trainingData)</code></pre>
<pre><code>## [1] &quot;ID&quot;    &quot;LABEL&quot;</code></pre>
<pre class="r"><code># Example paragraph Foreign Affairs
set.seed(13)
domestic_example &lt;- sample(trainingData$ID[trainingData$LABEL == &quot;DOMESTIC&quot;], 1)
as.character(texts(corpus)[domestic_example])</code></pre>
<pre><code>## [1] &quot;By the use of the State banks, which do not derive their charters from\nthe General Government and are not controlled by its authority, it is\nascertained that the moneys of the United States can be collected and\ndisbursed without loss or inconvenience, and that all the wants of the\ncommunity in relation to exchange and currency are supplied as well as\nthey have ever been before. If under circumstances the most unfavorable\nto the steadiness of the money market it has been found that the\nconsiderations on which the Bank of the United States rested its claims\nto the public favor were imaginary and groundless, it can not be\ndoubted that the experience of the future will be more decisive against\nthem.&quot;</code></pre>
<pre class="r"><code>foreign_example &lt;- sample(trainingData$ID[trainingData$LABEL == &quot;FOREIGN&quot;], 1)
as.character(texts(corpus)[foreign_example])</code></pre>
<pre><code>## [1] &quot;The International Atomic Energy Agency confirmed in the 1990s that Saddam\nHussein had an advanced nuclear weapons development program, had a design for a\nnuclear weapon, and was working on five different methods of enriching uranium\nfor a bomb. The British Government has learned that Saddam Hussein recently\nsought significant quantities of uranium from Africa. Our intelligence sources\ntell us that he has attempted to purchase high-strength aluminum tubes suitable\nfor nuclear weapons production. Saddam Hussein has not credibly explained these\nactivities. He clearly has much to hide.&quot;</code></pre>
<p>How is the ratio between domestic and foreign content in the training data?</p>
<pre class="r"><code>classCounts &lt;- table(trainingData[, &quot;LABEL&quot;])
print(classCounts)</code></pre>
<pre><code>## 
## DOMESTIC  FOREIGN 
##      209       91</code></pre>
<pre class="r"><code>numberOfDocuments &lt;- nrow(trainingData)</code></pre>
<p>For our first classification attempt, we create a Document-Term Matrix from the preprocessed corpus and use the extracted single words (unigrams) as features for the classification. Since the resulting DTM might contain too many words, we restrict the vocabulary to a minimum frequency.</p>
<pre class="r"><code># Base line: create feature set out of unigrams
# Probably the DTM is too big for the classifier. Let us reduce it
minimumFrequency &lt;- 5

DTM &lt;- corpus_token %&gt;% 
  dfm() %&gt;% 
  dfm_trim(min_docfreq = minimumFrequency, max_docfreq = Inf)

# How many features do we have?
dim(DTM)</code></pre>
<pre><code>## [1] 21334 10950</code></pre>
</div>
<div id="classification" class="section level1" number="3">
<h1 number="3"><span class="header-section-number">3</span> Classification</h1>
<p>Now we build a linear classification model with the LiblineaR package. The package LiblineaR wraps around the open source library LIBLINEAR which provides a very fast implementations for two text classification algorithms: 1. Logistic Regression, and 2. Support Vector Machines (SVM) with a linear kernel. For both algorithms, different regularization methods exist (e.g. L1, and L2-regularization). The combination of algorithms and regularization can be controlled by the <code>type</code> parameter of the <code>LiblineaR</code> function. We stick to the default type, L2-regularized logistic regression (LR), since it usually achieves good performance in text classification.</p>
<p>First, we load the packages. Since Liblinear requires a special Sparse Matrix format, we also load the “SparseM” package and a conversion function which allows to convert <code>quanteda's dfm</code>-matrices into <code>SparseM</code>-matrices.</p>
<p>Then, we split the annotated data into a training set (80%) and a test set (20%) using a boolean selector. The expression assigned to <code>selector_idx</code> creates a boolean vector of length 300 containing a FALSE value in every fifths position. This selector is used to select to training set. Its inverted vector (!) is used to select the test set.</p>
<pre class="r"><code>require(LiblineaR)
require(SparseM)
source(&quot;utils.R&quot;)

annotatedDTM &lt;- DTM[trainingData[, &quot;ID&quot;], ]
annotatedDTM &lt;- convertMatrixToSparseM(annotatedDTM)
annotatedLabels &lt;- trainingData[, &quot;LABEL&quot;]

# split into training and test set
selector_idx &lt;- rep(c(rep(TRUE, 4), FALSE), length.out = numberOfDocuments)
trainingDTM &lt;- annotatedDTM[selector_idx, ]
trainingLabels &lt;- annotatedLabels[selector_idx]
testDTM &lt;- annotatedDTM[!selector_idx, ]
testLabels &lt;- annotatedLabels[!selector_idx]

# create LR classification model
model &lt;- LiblineaR(trainingDTM, trainingLabels)
summary(model)</code></pre>
<pre><code>##            Length Class  Mode     
## TypeDetail     1  -none- character
## Type           1  -none- numeric  
## W          10951  -none- numeric  
## Bias           1  -none- numeric  
## ClassNames     2  factor numeric  
## NbClass        1  -none- numeric</code></pre>
<p>The model created by the LiblineaR function can now be utilized to predict the labels of the test set. Then we compare the result of the automatic classification to our known labels to determine the accuracy of the process.</p>
<pre class="r"><code>classification &lt;- predict(model, testDTM) </code></pre>
<pre><code>## Loading required package: SparseM</code></pre>
<pre><code>## 
## Attaching package: &#39;SparseM&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:base&#39;:
## 
##     backsolve</code></pre>
<pre class="r"><code>predictedLabels &lt;- classification$predictions
contingencyTable &lt;- table(predictedLabels, testLabels)
print(contingencyTable) </code></pre>
<pre><code>##                testLabels
## predictedLabels DOMESTIC FOREIGN
##        DOMESTIC       24       5
##        FOREIGN        21      10</code></pre>
<pre class="r"><code>accuracy &lt;- sum(diag(contingencyTable)) / length(testLabels)
print(accuracy) # share of correctly classified paragraphs</code></pre>
<pre><code>## [1] 0.567</code></pre>
<p>The accuracy of 0.567 appears moderate for a first try. But how does it actually relate to a base line? Think of the imbalanced class proportions in our training set. Let us create a pseudo classification as base line, in which we do not classify at all, but simply assume the label “DOMESTIC” or “FOREIGN” for each paragraph.</p>
<p>We further employ a function called <code>F.measure</code> which gives more differentiated measures than simple accuracy (<code>A</code>) to determine the classification quality. The F.measure (<code>F</code>) is the harmonic mean of Precision (<code>P</code>) and Recall (<code>R</code>) (see <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Definition_.28classification_context.29" class="uri">https://en.wikipedia.org/wiki/Precision_and_recall#Definition_.28classification_context.29</a> for Details).</p>
<pre class="r"><code># Create pseudo classification
pseudoLabelsDOM &lt;- factor(rep(&quot;DOMESTIC&quot;, length(testLabels)), levels(testLabels))
pseudoLabelsFOR &lt;- factor(rep(&quot;FOREIGN&quot;, length(testLabels)), levels(testLabels))

# Evaluation of former LR classification with F-measures
F.measure(predictedLabels, testLabels, positiveClassName = &quot;DOMESTIC&quot;)</code></pre>
<pre><code>##      P      R      S      F      A   Pos. 
##  0.828  0.533  0.667  0.649  0.567 45.000</code></pre>
<pre class="r"><code>F.measure(predictedLabels, testLabels, positiveClassName = &quot;FOREIGN&quot;)</code></pre>
<pre><code>##      P      R      S      F      A   Pos. 
##  0.323  0.667  0.533  0.435  0.567 15.000</code></pre>
<pre class="r"><code># Evaluation of pseudo classification with F-measures
F.measure(pseudoLabelsDOM, testLabels, positiveClassName = &quot;DOMESTIC&quot;)</code></pre>
<pre><code>##      P      R      S      F      A   Pos. 
##  0.750  1.000  0.000  0.857  0.750 45.000</code></pre>
<pre class="r"><code>F.measure(pseudoLabelsFOR, testLabels, positiveClassName = &quot;FOREIGN&quot;)</code></pre>
<pre><code>##     P     R     S     F     A  Pos. 
##  0.25  1.00  0.00  0.40  0.25 15.00</code></pre>
<p>This little experiment shows that depending on the definition of our positive class, the accuracy is either 25% or 75% if not classifying at all. In both cases the <em>specificity</em> (<code>S</code>), the true negative rate, is zero. From this, we can learn two things:</p>
<ol style="list-style-type: decimal">
<li>If classes in training/test sets are imbalanced, accuracy might be a misleading measurement. Other measure should be considered additionally.</li>
<li>To utilize accuracy and F-measure in a meaningful way, the less frequent class should be defined as POSITIVE class (FOREIGN in our case).</li>
</ol>
</div>
<div id="k-fold-cross-validation" class="section level1" number="4">
<h1 number="4"><span class="header-section-number">4</span> K-fold cross validation</h1>
<p>To evaluate a classifier, the training data can be divided into training and test data. The model learns on the former and is evaluated with the latter. In this procedure, we unfortunately lose the test data to learn from. If there is little training data available, the k-fold cross-validation is a more suitable procedure.</p>
<p>For this, training data is split into e.g. K = 10 parts. Then k-1 parts are used for training and 1 part is used for testing. This process is repeated k times, with another split of the overall data set for testing in each iteration.</p>
<p>The final result is determined from the average of the quality of the k runs. This allows a good approximation to the classification quality, including all training data.</p>
<p>The <code>get_k_fold_logical_indexes</code> function introduced below returns a logical vector for the fold <code>j</code> for cross-validation. It splits a training data record of the size <code>n</code> into <code>k</code> folds. The resulting vector and its negated vector can be used for easy training data / test data selection.</p>
<pre class="r"><code>get_k_fold_logical_indexes &lt;- function(j, k, n) {
  if (j &gt; k) stop(&quot;Cannot select fold larger than nFolds&quot;)
  fold_lidx &lt;- rep(FALSE, k)
  fold_lidx[j] &lt;- TRUE
  fold_lidx &lt;- rep(fold_lidx, length.out = n)
  return(fold_lidx)
}

# Example usage
get_k_fold_logical_indexes(1, k = 10, n = 12)</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>get_k_fold_logical_indexes(2, k = 10, n = 12)</code></pre>
<pre><code>##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>get_k_fold_logical_indexes(3, k = 10, n = 12)</code></pre>
<pre><code>##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<p>Now we run 1) splitting of the annotated data, 2) model computation and testing in one for-loop.</p>
<pre class="r"><code>k &lt;- 10
evalMeasures &lt;- NULL
for (j in 1:k) {
  # create j-th boolean selection vector
  currentFold &lt;- get_k_fold_logical_indexes(j, k, nrow(trainingDTM))
  
  # select training data split
  foldDTM &lt;- annotatedDTM[!currentFold, ]
  foldLabels &lt;- annotatedLabels[!currentFold]
  
  # create model
  model &lt;- LiblineaR(foldDTM, foldLabels)
  
  # select test data split
  testSet &lt;- annotatedDTM[currentFold, ]
  testLabels &lt;- annotatedLabels[currentFold]
  
  # predict test labels
  predictedLabels &lt;- predict(model, testSet)$predictions
  
  # evaluate predicted against test labels
  kthEvaluation &lt;- F.measure(predictedLabels, testLabels, positiveClassName = &quot;FOREIGN&quot;)
  
  # combine evaluation measures for k runs
  evalMeasures &lt;- rbind(evalMeasures, kthEvaluation)
}
# Final evaluation values of k runs:
print(evalMeasures)</code></pre>
<pre><code>##                   P     R     S     F     A Pos.
## kthEvaluation 0.333 0.400 0.600 0.364 0.533   10
## kthEvaluation 0.737 0.875 0.643 0.800 0.767   16
## kthEvaluation 0.333 0.429 0.739 0.375 0.667    7
## kthEvaluation 0.467 0.778 0.619 0.583 0.667    9
## kthEvaluation 0.333 0.571 0.652 0.421 0.633    7
## kthEvaluation 0.312 0.714 0.522 0.435 0.567    7
## kthEvaluation 0.471 0.727 0.526 0.571 0.600   11
## kthEvaluation 0.500 0.833 0.792 0.625 0.800    6
## kthEvaluation 0.526 1.000 0.550 0.690 0.700   10
## kthEvaluation 0.385 0.625 0.636 0.476 0.633    8</code></pre>
<pre class="r"><code># Average over all folds
print(colMeans(evalMeasures))</code></pre>
<pre><code>##     P     R     S     F     A  Pos. 
## 0.440 0.695 0.628 0.534 0.657 9.100</code></pre>
<p>Accuracy is around 66 %, F-measure is around 53 %. Let’s try some approaches to optimize the automatic classification.</p>
</div>
<div id="optimization" class="section level1" number="5">
<h1 number="5"><span class="header-section-number">5</span> Optimization</h1>
<p>These first tries have clarified how to utilize and evaluate machine learning functions for text in R. Now we concentrate on optimization strategies to get better results from the automatic classification process.</p>
<div id="c-parameter" class="section level2" number="5.1">
<h2 number="5.1"><span class="header-section-number">5.1</span> C-Parameter</h2>
<p>For a linear classification model, the cost parameter (C-parameter) is the most important parameter to tweak (for other SVM kernels such as the radial or polynomial kernel there are other important parameters which influence the shape of the kernel function). The <strong>C-parameter</strong> determines the cost of classifications on the training data during training.</p>
<p>High values of C lead to a high costs of misclassification. The decision boundary which the classifier learns, will try to avoid any misclassification. But, values too high can lead to an overfitting of the model. This means, it adapts well to the training data, but classification will more likely fail on new test data.</p>
<p>Low values of C lead to less strict decision boundaries, which accepts some misclassifications. Such a model might generalize better on unseen data. But in the end, there is now exact method to determine a good C-value beforehand. It rather is an empirical question. To choose an optimal C-value, we simply try from a range of values, run k-fold-cross-validation for each single value and decide for the C which resulted in the best classification accuracy / F-measure. This is realized in the following for-loop, which utilizes the function <code>k_fold_cross_validation</code>. The function (have a look into <code>F.measure.R</code>) simply wraps the code for cross-validation, we used above.</p>
<pre class="r"><code>cParameterValues &lt;- c(0.003, 0.01, 0.03, 0.1, 0.3, 1, 3 , 10, 30, 100)
fValues &lt;- NULL

for (cParameter in cParameterValues) {
  print(paste0(&quot;C = &quot;, cParameter))
  evalMeasures &lt;- k_fold_cross_validation(annotatedDTM, annotatedLabels, cost = cParameter)
  fValues &lt;- c(fValues, evalMeasures[&quot;F&quot;])
}</code></pre>
<pre><code>## [1] &quot;C = 0.003&quot;
## [1] &quot;C = 0.01&quot;
## [1] &quot;C = 0.03&quot;
## [1] &quot;C = 0.1&quot;
## [1] &quot;C = 0.3&quot;
## [1] &quot;C = 1&quot;
## [1] &quot;C = 3&quot;
## [1] &quot;C = 10&quot;
## [1] &quot;C = 30&quot;
## [1] &quot;C = 100&quot;</code></pre>
<pre class="r"><code>plot(fValues, type=&quot;o&quot;, col=&quot;green&quot;, xaxt=&quot;n&quot;)
axis(1,at=1:length(cParameterValues), labels = cParameterValues)</code></pre>
<p><img src="Tutorial_7_Klassifikation_files/figure-html/optimizeC-1.png" width="672" /></p>
<pre class="r"><code>bestC &lt;- cParameterValues[which.max(fValues)]
print(paste0(&quot;Best C value: &quot;, bestC, &quot;, F1 = &quot;, max(fValues)))</code></pre>
<pre><code>## [1] &quot;Best C value: 3, F1 = 0.542941816588523&quot;</code></pre>
<p>From the empirical test, we can obtain C = 3 as optimal choice for the cost parameter. On the current training data set with the current features it achieves 0.543 F-score.</p>
</div>
<div id="optimized-preprocessing" class="section level2" number="5.2">
<h2 number="5.2"><span class="header-section-number">5.2</span> Optimized Preprocessing</h2>
<p>Not only the classification model has parameters which can be optimized to improve the results. More important are the features used for classification. In our preprocessing chain above, we extracted single types and transformed them into lower case. We now add different preprocessing steps and check on the results. To get an optimal cost parameter for each new feature set, we wrapped the code for C-parameter optimization into the <code>optimize_C</code> function.</p>
<p><strong>Stop word removal</strong></p>
<p>Stop words often do not contribute to the meaning of a text. For the decision between DOMESTIC and FOREIGN affairs, we do not expect any useful information from them. So let’s remove them and if it improves the classifier.</p>
<pre class="r"><code>stopwords_extended &lt;- readLines(&quot;resources/stopwords_en.txt&quot;, encoding = &quot;UTF-8&quot;)

# preprocessing
corpus_token_sw &lt;- corpus %&gt;% 
  tokens(remove_punct = TRUE, remove_numbers = TRUE, remove_symbols = TRUE) %&gt;% 
  tokens_tolower() %&gt;% 
  tokens_remove(pattern = stopwords_extended)

print(paste0(&quot;1: &quot;, substr(paste(corpus_token_sw[4963],collapse = &quot; &quot;), 0, 400), &#39;...&#39;))</code></pre>
<pre><code>## [1] &quot;1: legislation extend colony newfoundland articles treaty washington 8th day protocol effect signed behalf united states great britain 28th day duly proclaimed day copy proclamation submitted herewith...&quot;</code></pre>
<pre class="r"><code>minimumFrequency &lt;- 5

# Compute DTM
DTM &lt;- corpus_token_sw %&gt;% 
  dfm() %&gt;% 
  dfm_trim(min_docfreq = minimumFrequency,max_docfreq = Inf)

# How many features do we have?
dim(DTM)</code></pre>
<pre><code>## [1] 21334 10448</code></pre>
<pre class="r"><code># run cross validation
annotatedDTM &lt;- convertMatrixToSparseM(DTM[trainingData[, &quot;ID&quot;], ])
best_C &lt;- optimize_C(annotatedDTM, annotatedLabels)</code></pre>
<pre><code>## [1] &quot;C = 0.003&quot;
## [1] &quot;C = 0.01&quot;
## [1] &quot;C = 0.03&quot;
## [1] &quot;C = 0.1&quot;
## [1] &quot;C = 0.3&quot;
## [1] &quot;C = 1&quot;
## [1] &quot;C = 3&quot;
## [1] &quot;C = 10&quot;
## [1] &quot;C = 30&quot;
## [1] &quot;C = 100&quot;
## [1] &quot;Best C value: 0.03, F1 = 0.647465370415286&quot;</code></pre>
<pre class="r"><code>k_fold_cross_validation(annotatedDTM, annotatedLabels, cost = best_C)</code></pre>
<pre><code>##     P     R     S     F     A  Pos. 
## 0.596 0.725 0.800 0.647 0.780 9.100</code></pre>
<p><strong>Bigrams</strong></p>
<p>Now let us see, if the use of bigrams, i.e. concatenations of sequences of two words can improve the result. Bigrams, and larger n-Grams can capture important sequential contexts from texts such as negation, at least to a certain extent. For instance, “is not funny” will result in the features “is_not” and “not_funny.”</p>
<p>To extract n-gram features, the <code>tokens_ngrams()</code> of <code>quanteda</code> accepts a list of integers, e.g. <code>1:2</code> to create unigram and bigram features.</p>
<pre class="r"><code>corpus_token_bigrams &lt;- corpus %&gt;% 
  tokens(remove_punct = TRUE, remove_numbers = TRUE, remove_symbols = TRUE) %&gt;% 
  tokens_tolower() %&gt;% 
  tokens_remove(pattern = stopwords_extended) %&gt;%
  tokens_ngrams(1:2)

print(paste0(&quot;1: &quot;, substr(paste(corpus_token_bigrams[4963], collapse = &quot; &quot;), 0, 400), &#39;...&#39;))</code></pre>
<pre><code>## [1] &quot;1: legislation extend colony newfoundland articles treaty washington 8th day protocol effect signed behalf united states great britain 28th day duly proclaimed day copy proclamation submitted herewith legislation_extend extend_colony colony_newfoundland newfoundland_articles articles_treaty treaty_washington washington_8th 8th_day day_protocol protocol_effect effect_signed signed_behalf behalf_united...&quot;</code></pre>
<pre class="r"><code># Compute DTM
DTM &lt;- corpus_token_bigrams  %&gt;% 
  dfm() %&gt;% 
  dfm_trim(min_docfreq = minimumFrequency, max_docfreq = Inf)

# How many features do we have now?
dim(DTM)</code></pre>
<pre><code>## [1] 21334 22800</code></pre>
<pre class="r"><code># How do they look like?
sample(colnames(DTM), 10)</code></pre>
<pre><code>##  [1] &quot;accessible&quot;          &quot;means_national&quot;      &quot;great_moment&quot;        &quot;logic&quot;              
##  [5] &quot;idealism&quot;            &quot;government_congress&quot; &quot;advisory&quot;            &quot;joint_commission&quot;   
##  [9] &quot;number_ships&quot;        &quot;buy&quot;</code></pre>
<pre class="r"><code># run cross validation
annotatedDTM &lt;- convertMatrixToSparseM(DTM[trainingData[, &quot;ID&quot;], ])
best_C &lt;- optimize_C(annotatedDTM, annotatedLabels)</code></pre>
<pre><code>## [1] &quot;C = 0.003&quot;
## [1] &quot;C = 0.01&quot;
## [1] &quot;C = 0.03&quot;
## [1] &quot;C = 0.1&quot;
## [1] &quot;C = 0.3&quot;
## [1] &quot;C = 1&quot;
## [1] &quot;C = 3&quot;
## [1] &quot;C = 10&quot;
## [1] &quot;C = 30&quot;
## [1] &quot;C = 100&quot;
## [1] &quot;Best C value: 0.03, F1 = 0.644608227558143&quot;</code></pre>
<pre class="r"><code>k_fold_cross_validation(annotatedDTM, annotatedLabels, cost = best_C)</code></pre>
<pre><code>##     P     R     S     F     A  Pos. 
## 0.591 0.725 0.795 0.645 0.777 9.100</code></pre>
<p>In this case, bi-gram and tri-gram features seem to not contribute positively to the classification result.</p>
<p><strong>Minimum feature frequency</strong></p>
<p>Up to this point, we dropped features occurring less than five times in our data. Let’s see if we include more features by increasing the minimum frequency.</p>
<pre class="r"><code># More features
minimumFrequency &lt;- 2

DTM &lt;- corpus_token_sw  %&gt;% 
  dfm() %&gt;% 
  dfm_trim(min_docfreq = minimumFrequency, max_docfreq = Inf)

dim(DTM)</code></pre>
<pre><code>## [1] 21334 16689</code></pre>
<pre class="r"><code>annotatedDTM &lt;- convertMatrixToSparseM(DTM[trainingData[, &quot;ID&quot;], ])
best_C &lt;- optimize_C(annotatedDTM, annotatedLabels)</code></pre>
<pre><code>## [1] &quot;C = 0.003&quot;
## [1] &quot;C = 0.01&quot;
## [1] &quot;C = 0.03&quot;
## [1] &quot;C = 0.1&quot;
## [1] &quot;C = 0.3&quot;
## [1] &quot;C = 1&quot;
## [1] &quot;C = 3&quot;
## [1] &quot;C = 10&quot;
## [1] &quot;C = 30&quot;
## [1] &quot;C = 100&quot;
## [1] &quot;Best C value: 0.03, F1 = 0.651274894224809&quot;</code></pre>
<pre class="r"><code>k_fold_cross_validation(annotatedDTM, annotatedLabels, cost = best_C)</code></pre>
<pre><code>##     P     R     S     F     A  Pos. 
## 0.602 0.725 0.804 0.651 0.783 9.100</code></pre>
<p>It seems that feeding more features into the classifier has a little positive effect on the result.</p>
<p><strong>Lemmatization</strong></p>
<p>As a last method, we utilize lemmatization to unify different variants of the same semantic form (such as <em>nation</em> and <em>nations</em>).</p>
<pre class="r"><code>corpus_token_lemma &lt;- corpus %&gt;% 
  tokens(remove_punct = TRUE, remove_numbers = TRUE, remove_symbols = TRUE) %&gt;% 
  tokens_tolower() %&gt;% 
  tokens_replace(lemma_data$inflected_form, lemma_data$lemma, valuetype = &quot;fixed&quot;) %&gt;%
  tokens_remove(pattern = stopwords_extended) %&gt;%
  tokens_ngrams(1)

print(paste0(&quot;1: &quot;, substr(paste(corpus_token_lemma[4963], collapse = &quot; &quot;), 0, 400), &#39;...&#39;))</code></pre>
<pre><code>## [1] &quot;1: legislation extend colony newfoundland article treaty washington 8th day protocol effect sign behalf unite state great britain 28th day duly proclaim follow day copy proclamation submit herewith...&quot;</code></pre>
<pre class="r"><code>minimumFrequency &lt;- 2

DTM &lt;- corpus_token_lemma  %&gt;% 
  dfm() %&gt;% 
  dfm_trim(min_docfreq = minimumFrequency, max_docfreq = Inf)

dim(DTM)</code></pre>
<pre><code>## [1] 21334 11523</code></pre>
<pre class="r"><code># run cross validation
annotatedDTM &lt;- convertSlamToSparseM(DTM[trainingData[, &quot;ID&quot;], ])
best_C &lt;- optimize_C(annotatedDTM, annotatedLabels)</code></pre>
<pre><code>## [1] &quot;C = 0.003&quot;
## [1] &quot;C = 0.01&quot;
## [1] &quot;C = 0.03&quot;
## [1] &quot;C = 0.1&quot;
## [1] &quot;C = 0.3&quot;
## [1] &quot;C = 1&quot;
## [1] &quot;C = 3&quot;
## [1] &quot;C = 10&quot;
## [1] &quot;C = 30&quot;
## [1] &quot;C = 100&quot;
## [1] &quot;Best C value: 0.03, F1 = 0.69005439005439&quot;</code></pre>
<pre class="r"><code>k_fold_cross_validation(annotatedDTM, annotatedLabels, cost = best_C)</code></pre>
<pre><code>##     P     R     S     F     A  Pos. 
## 0.641 0.767 0.817 0.690 0.807 9.100</code></pre>
<p>Each individual approach to optimize our text features for classification has some effect on the results. It takes some time to engineer an optimal feature set.</p>
<p>Further, testing different features must be done for each new task / language individually, since there is no “one-size fits all” approach to this.</p>
<p>GENERAL ADVISE: For this tutorial we utilized a rather small training set of 300 examples, 91 of them in the positive class. Better classification accuracy can be expected, if more training data is available. Hence, instead of spending too much time on feature optimization, it will probably be a better idea to invest into generation of more training data first.</p>
</div>
</div>
<div id="final-classification" class="section level1" number="6">
<h1 number="6"><span class="header-section-number">6</span> Final classification</h1>
<p>We now apply our best classification model to the entire data set, to determine the occurrence of FORGEIN/DOMESTIC affairs related content in each single speech.</p>
<pre class="r"><code># Final classification
annotatedDTM &lt;- convertMatrixToSparseM(DTM[trainingData[, &quot;ID&quot;], ])

# C parameter tuning
best_C &lt;- optimize_C(annotatedDTM, annotatedLabels)</code></pre>
<pre><code>## [1] &quot;C = 0.003&quot;
## [1] &quot;C = 0.01&quot;
## [1] &quot;C = 0.03&quot;
## [1] &quot;C = 0.1&quot;
## [1] &quot;C = 0.3&quot;
## [1] &quot;C = 1&quot;
## [1] &quot;C = 3&quot;
## [1] &quot;C = 10&quot;
## [1] &quot;C = 30&quot;
## [1] &quot;C = 100&quot;
## [1] &quot;Best C value: 0.03, F1 = 0.69005439005439&quot;</code></pre>
<pre class="r"><code># final classification
final_model &lt;- LiblineaR(annotatedDTM, annotatedLabels, cost = best_C)
final_labels &lt;- predict(final_model, convertSlamToSparseM(DTM))$predictions
table(final_labels) / sum(table(final_labels))</code></pre>
<pre><code>## final_labels
## DOMESTIC  FOREIGN 
##    0.594    0.406</code></pre>
<p>We see that the classifier puts the majority of the around 21,000 paragraphs into the DOMESTIC category. We can visualize the result as a bar chart with <code>ggplot2</code>. For better readability</p>
<pre class="r"><code>speech_year &lt;- substr(textdata$date, 0, 4)
speech_id &lt;- textdata$speech_doc_id
paragraph_position &lt;- unlist(sapply(table(speech_id), FUN = function(x) {1:x}))
presidents_df &lt;- data.frame(
  paragraph_position = paragraph_position,
  speech = paste0(speech_id, &quot;: &quot;, textdata$president, &quot;_&quot;, speech_year),
  category = final_labels
)

# preserve speech order in chart by using factors
presidents_df$speech &lt;- factor(presidents_df$speech, levels = unique(presidents_df$speech))

# Remove two very long speeches to beautify the plot (you can also skip this)
presidents_df &lt;- presidents_df[!grepl(&quot;Carter_1981|Truman_1946&quot;, presidents_df$speech), ]

# plot classes of paragraphs for each speech as tile
require(ggplot2)
ggplot(presidents_df, aes(x = speech, y = paragraph_position, fill = category)) + 
  geom_tile(stat=&quot;identity&quot;) + coord_flip()</code></pre>
<p><img src="Tutorial_7_Klassifikation_files/figure-html/finalClassification2-1.png" width="960" /></p>
<p>Can you see how DOMESTIC affairs related content gets more important over the course of centuries? Also the position of FOREIGN policy statements changes around the turn from the 19th to 20th century from the begginning of a speech to more dispersed positions thoughout the speech, and finally a tendency to rather place them at the end of speeches.</p>
</div>
<div id="optional-exercises" class="section level1" number="7">
<h1 number="7"><span class="header-section-number">7</span> Optional exercises</h1>
<ol style="list-style-type: decimal">
<li>Divide the training data into a 60% training set and 40% test set. Train a classifier on the training set and evaluate the performance on the test set. As performance measure use <strong>Cohen’s Kappa</strong>, <strong>Krippendorff’a alpha</strong>, and simple <strong>Percentage agreement</strong> as provided in the <code>irr</code> package for R.</li>
</ol>
<pre><code>##      P      R      S      F      A   Pos. 
##  0.650  0.703  0.831  0.675  0.792 37.000</code></pre>
<pre><code>##  Cohen&#39;s Kappa for 2 Raters (Weights: unweighted)
## 
##  Subjects = 120 
##    Raters = 2 
##     Kappa = 0.522 
## 
##         z = 5.73 
##   p-value = 9.99e-09</code></pre>
<pre><code>##  Krippendorff&#39;s alpha
## 
##  Subjects = 120 
##    Raters = 2 
##     alpha = 0.524</code></pre>
<pre><code>##  Percentage agreement (Tolerance=0)
## 
##  Subjects = 120 
##    Raters = 2 
##   %-agree = 79.2</code></pre>
<p><em>NOTICE:</em> Since we have a very small annotated data set, the evaluation performance varies greatly with respect to the random selection of which paragraphs are sampled either into the training or test set.</p>
<ol start="2" style="list-style-type: decimal">
<li>Use the <code>proba = T</code> parameter for the <code>predict</code> method during the final classification to evaluate on label probabilities instead of discrete label decisions. Use the output of probabilities for the label “FOREIGN” to classify paragraphs as “FOREIGN” only if the label probability is greater than 60%. Visualize the result. What can you observe compared to the previous plot (decision boundary around 50%)?</li>
</ol>
<p><img src="Tutorial_7_Klassifikation_files/figure-html/ex2-1.png" width="960" /></p>
</div>

<p>2020, Andreas Niekler and Gregor Wiedemann. GPLv3. <a href="https://tm4ss.github.io">tm4ss.github.io</a></p>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
